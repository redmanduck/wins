#define WINSD_VER "monitor_2.0"
#define BUF_SIZE 1024
#define CHUNK_SIZE 256
#define TIME_BETWEEN_CHUNK 5000
#define TIME_BETWEEN_BUF 10000
#include <time.h>

#include <bcm2835.h>
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <sys/time.h>

#include "animation.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include "I2Cdev.h"
#include "MPU6050_6Axis_MotionApps20.h"

// class default I2C address is 0x68
// specific I2C addresses may be passed as a parameter here
// AD0 low = 0x68 (default for SparkFun breakout and InvenSense evaluation board)
// AD0 high = 0x69
MPU6050 mpu(0x69);
// uncomment "OUTPUT_READABLE_QUATERNION" if you want to see the actual
// quaternion components in a [w, x, y, z] format (not best for parsing
// on a remote host such as Processing or something though)
#define OUTPUT_READABLE_QUATERNION
unsigned char devStatus;
unsigned char mpuIntStatus;
unsigned int packetSize;
bool dmpReady = false;

Quaternion q;
VectorInt16 aa;
VectorInt16 aaReal;
VectorFloat gravity;
float ypr[3];

void setup() {
    // initialize device
    printf("Initializing I2C devices...\n");
    mpu.initialize();

    // verify connection
    printf("Testing device connections...\n");
    printf(mpu.testConnection() ? "MPU6050 connection successful\n" : "MPU6050 connection failed\n");

    // load and configure the DMP
    printf("Initializing DMP...\n");
    devStatus = mpu.dmpInitialize();

    // make sure it worked (returns 0 if so)
    if (devStatus == 0) {
        // turn on the DMP, now that it's ready
        printf("Enabling DMP...\n");
        mpu.setDMPEnabled(true);

        // enable Arduino interrupt detection
        //Serial.println(F("Enabling interrupt detection (Arduino external interrupt 0)..."));
        //attachInterrupt(0, dmpDataReady, RISING);
        mpuIntStatus = mpu.getIntStatus();

        // set our DMP Ready flag so the main loop() function knows it's okay to use it
        printf("DMP ready!\n");
        dmpReady = true;

        // get expected DMP packet size for later comparison
        packetSize = mpu.dmpGetFIFOPacketSize();
    } else {
        // ERROR!
        // 1 = initial memory load failed
        // 2 = DMP configuration updates failed
        // (if it's going to break, usually the code will be 1)
        printf("DMP Initialization failed (code %d)\n", devStatus);
    }
}

enum opcode {
    IMU = 'M',
    ACCEL = 'A',
    GYRO = 'G',
    KEYPAD = 'K',
    HALT = 'H',
    ULTRASONIC = 'U',
    POSITION = 'P',
    VALID = 'V',
    ERROR = 'E',
    BAT = 'B',
};

int main() {
	// Setup IMU to get DMP data
    setup();
    usleep(100000);

    if (!bcm2835_init()) {
        return 1;
    }
    bcm2835_spi_begin();
    bcm2835_spi_setChipSelectPolarity(BCM2835_SPI_CS0, 0);
    bcm2835_spi_setChipSelectPolarity(BCM2835_SPI_CS1, 0);
    bcm2835_spi_setClockDivider(BCM2835_SPI_CLOCK_DIVIDER_256); //4096); //2048);
    bcm2835_spi_setDataMode(BCM2835_SPI_MODE1);
    bcm2835_spi_chipSelect(BCM2835_SPI_CS0);

    int var = 0;
    uint8_t imu_buf[BUF_SIZE];
    for (var = 0; var < BUF_SIZE; var++) {
        imu_buf[var] = 0x00;
    }
    char * lcd_buf = getBitmap();
    char RX = '0';
    char TX = '0';
    int i = 0;
    int ct = 0;
    int err = 0;
    int op_err = 0;
    int packets = 0;
    int seconds = 0;
    unsigned char bat1 = 0;
    unsigned char bat2 = 0;
    int data_p = 0;
    printf("Begin\n");
    while (1) {
		    clock_t total = clock();
        // Establishing communication for getting battery data
        TX = BAT;
        RX = bcm2835_spi_transfer(TX);
        RX = bcm2835_spi_transfer(TX);
        while (RX != BAT) {
            op_err++;
            usleep(10000);
            RX = bcm2835_spi_transfer(TX);
            printf("| tx:%x rx:%x(%c) |", TX, RX, RX);
            if (op_err % 10 == 0)
                printf("\n");
        }
        RX = bcm2835_spi_transfer(TX);
        bat1 = RX;
        RX = bcm2835_spi_transfer(TX);
        bat2 = RX;
        // battery status is stored in bat1 and bat2
        data_p = 0;

        //trasnferring 1024 bytes of data: 12 at a time
        while (data_p < BUF_SIZE) {
            TX = ACCEL;
            RX = bcm2835_spi_transfer(TX);
            RX = bcm2835_spi_transfer(TX);
            while (RX != ACCEL) {
                op_err++;
                usleep(10000);
                RX = bcm2835_spi_transfer(TX);
                printf("| tx:%x rx:%x(%c) |", TX, RX, RX);
                if (op_err % 10 == 0)
                    printf("\n");
            }
            //printf("%d:Bat: %d%% %f Data: ", data_p, bat1, (bat1 + (float) bat2 / 256));
            for (i = 0; i < CHUNK_SIZE; i++) {
                TX = lcd_buf[data_p + i];
                RX = bcm2835_spi_transfer(TX);
                imu_buf[data_p + i] = RX;
                //printf("%x ", RX);
            }
            mpu.dmpGetQuaternion(&q, &imu_buf[data_p]);
            mpu.dmpGetGravity(&gravity, &q);
            mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);
            if(packets%10==5)
              printf("ypr  %7.2f %7.2f %7.2f   \n", ypr[0] * 180 / M_PI, ypr[1] * 180 / M_PI, ypr[2] * 180 / M_PI);
            /*
            int x = (imu_buf[data_p + 0] << 8) | imu_buf[data_p + 1];
            int y = (imu_buf[data_p + 2] << 8) | imu_buf[data_p + 3];
            int z = (imu_buf[data_p + 4] << 8) | imu_buf[data_p + 5];
            int gx = (imu_buf[data_p + 6] << 8) | imu_buf[data_p + 7];
            int gy = (imu_buf[data_p + 8] << 8) | imu_buf[data_p + 9];
            int gz = (imu_buf[data_p + 10] << 8) | imu_buf[data_p + 11];
            printf("\nax:%d y:%d z:%d. gx:%d y:%d z:%d\n", x, y, z, gx, gy, gz);
            */
            RX = bcm2835_spi_transfer(TX);
            if (RX == VALID) {
                data_p += CHUNK_SIZE;
            }
            //float diffsec = (float) (clock() - total) / CLOCKS_PER_SEC;
            //printf("\nERR %d|| total time = %f\n", op_err, diffsec);


            //  gettimeofday(&tval_after, NULL);
            //   timersub(&tval_after, &tval_before, &tval_result);
            //   printf(" ---- transfer time %ld.%06ld sec", (long int)tval_result.tv_sec, (long int)tval_result.tv_usec);
            //   ct++;
            //   printf("\n");
            //if(packets%100==0)
            usleep(TIME_BETWEEN_CHUNK);
        }
 //       printf("PACKET %d successfully transferred\n", packets);
        packets++;
        lcd_buf = getBitmap();
        usleep(TIME_BETWEEN_BUF);
    }

    bcm2835_spi_end();
    bcm2835_close();

}
/*
    0x00, 0x00,0x00, 0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,
    0xFE,0x02,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xFE,0x20,0x10,0x08,0xFE,0x00,0x3E,0x48,0x88,0x48,0x3E,0x00,0xF8,0x04,0x02,0x04,
    0xF8,0x00,0x00,0x82,0xFE,0x82,0x00,0x00,0x7C,0x82,0x82,0x8A,0xCE,0x00,0x3E,0x48,
    0x88,0x48,0x3E,0x00,0xC0,0x80,0xFE,0x80,0xC0,0x00,0x00,0x82,0xFE,0x82,0x00,0x00,
    0x7C,0x82,0x82,0x82,0x7C,0x00,0xFE,0x20,0x10,0x08,0xFE,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4E,0x92,
    0x92,0x92,0x62,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xFC,0x02,0x1C,0x02,0xFC,0x00,0xFE,0x10,0x10,0x10,0xFE,0x00,0xFE,0x92,0x92,0x92,
    0x82,0x00,0xFE,0x90,0x98,0x94,0x62,0x00,0xFE,0x92,0x92,0x92,0x82,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3E,0x48,0x88,0x48,0x3E,0x00,0xFE,0x40,0x38,0x40,0xFE,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x82,0xFE,0x82,0x00,0x00,0x40,0x80,0x9A,0x90,
    0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x82,
    0x92,0xB2,0xCC,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x64,0x92,0x92,0x92,0x4C,0x00,0xFE,0x10,0x10,0x10,0xFE,0x00,0xFC,0x02,0x02,0x02,
    0xFC,0x00,0xC0,0x80,0xFE,0x80,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x82,
    0x82,0x82,0x7C,0x00,0x7C,0x82,0x82,0x82,0x7C,0x00,0xFC,0x02,0x1C,0x02,0xFC,0x00,
    0xFE,0x20,0x10,0x08,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};
     */
